classdef IK
    methods (Static)     
        function [theta, info] = IK_solver(L, Ptraj, Qtraj, theta0)
            M = size(Ptraj,2);

            if size(Qtraj,2) ~= 1 || ~isa(Qtraj, 'quaternion')
                if isa(Qtraj,'quaternion') && size(Qtraj,1) == M
                elseif isa(Qtraj,'quaternion') && size(Qtraj,2) == M
                    Qtraj = Qtraj.';
                else
                    error('Qtraj must be Mx1 quaternion array');
                end
            end
            Qtraj = Quat.quat_normalize(Qtraj);

            theta = zeros(6,M);
            th = real(double(theta0(:)));

            Lc = sum(L); % 位置誤差を e_p=(p_des−p_cur)/Lc で正規化(アームが長いほど位置誤差が小さく見積もられる, その結果 tol_pos を満たしやすく、更新前に"収束"扱いになりがち)
            maxIter = 200; % 反復・停止条件(小さい→到達前に打ち切り, 大きい→遅いが安定)
            tol_pos = 1e-5; % 収束閾値(大きい→すぐ収束（更新しないように見える）, 小さい→粘る（遅い／収束しないリスク）)
            tol_ori = 1e-4;
            maxStep = 60*pi/180; % 1反復の角度上限(小さい→常時クリップ→**dθ≈0 で"進まない"**症状, 大きい→収束早いがオーバーシュート増。45〜60°で緩めて様子見が定石)
            back_beta = 0.8; % 縮小率(小さい（例:0.5）→縮小速い＝受理されやすいが小刻み, 大きい（例:0.8）→なかなか縮まらず不採択連発の恐れ)
            back_max = 20; % 最大回数(小さい→試行不足で不採択→停滞, 大きい→試行過多で遅いが、受理ゼロは避けやすい)

            info = struct();
            info.iter = zeros(1,M);
            info.status_per_t = repmat({''},1,M);

            for t = 1:M
                p_des = Ptraj(:,t);
                q_des = Qtraj(t,1);

                th_best = th; F_best = inf; status = 'running';

                for it = 1:maxIter
                    [p_cur, q_cur] = Kin.FK_posori(L, th);
                    e_p = (p_des - p_cur) / Lc;
                    e_o = Quat.quat_log_err(q_des, q_cur);
                    e = [e_p; e_o];

                    if norm(e(1:3)) < tol_pos && norm(e(4:6)) < tol_ori
                        status='ok';
                        break;
                    end

                    J = Kin.numJacobian(L, th, @Kin.FK_posori, q_des, Lc);

                    w_pos = 1.0; % 位置の重み(上げる→位置追従が最優先、姿勢が犠牲になりやすい, 下げる→位置許容、姿勢が相対的に効きやすい)
                    w_ori =1.0; % 姿勢の重み(上げる→姿勢も動かしたいときに有効。大きすぎると位置が鈍る, 下げる→姿勢はほぼ無視。角度が"更新されない"と感じる一因になりやすい)

                    W = diag([w_pos w_pos w_pos w_ori w_ori w_ori]);
                    eW = W * e;
                    JW = W * J;

                    if rcond(JW) > 1e-10
                        dth = JW \ eW;
                    else
                        dth = pinv(JW) * eW;
                    end

                    scale = max(1, max(abs(dth)/maxStep));
                    dth_limited = dth / scale;

                    F0 = 0.5*norm(eW)^2; g = JW.'*eW; step = 1.0; accepted = false;
                    th_cand = th; e_cand = e; F_cand = F0;
                    for k = 1:back_max
                        th_try = th + step*dth_limited;

                        [p_try, q_try] = Kin.FK_posori(L, th_try);

                        e_try = [ (p_des - p_try)/Lc ; Quat.quat_log_err(q_des, q_try) ];
                        eW_try = W * e_try;
                        F1 = 0.5*norm(eW_try)^2;
                        c1 = 1e-4;
                        if F1 <= F0 - c1*step*(norm(g)^2)
                            th_cand = th_try; e_cand = e_try; F_cand = F1; accepted = true; break;
                        end
                        step = step * back_beta;
                    end

                    if accepted
                        th = th_cand; e = e_cand; F0 = F_cand;
                        if F_cand < F_best
                            th_best = th; F_best = F_cand;
                        end
                        lambda_min = max(1e-5, 0.7*lambda_min);
                    else
                        lambda_min = min(1.0, 2*lambda_min);
                        if norm(g,inf) < 1e-6
                            status='no_progress'; break;
                        end
                    end

                    if norm(J.'*e,inf) < 1e-6
                        status='stationary';
                        break;
                    end
                    if norm(dth_limited,inf) < 1e-7
                        status='stalled';
                        break;
                    end
                end

                theta(:,t) = th_best;

                info.iter(t) = it;
                info.status_per_t{t}= status;

                th = theta(:,t);

                if any(strcmp(status, {'fkNaN','JNaN'}))
                    cols = M - t;
                    if cols > 0
                        theta(:, t+1:end) = repmat(theta(:, t), 1, cols);
                    end
                    info.status = status; info.t = t; return;
                end
            end

            if ~isfield(info,'status'), info.status = 'ok'; end
            info.maxIter = maxIter;
        end
    end
end